<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup theme-color -->
<!-- start theme color meta headers -->
<meta name="theme-color" content="#151515">
<meta name="msapplication-navbutton-color" content="#151515">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- end theme color meta headers -->


<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->


<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Exploiting POST-Based CSRF | /home/Gal1leo</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Exploiting POST-Based CSRF" />
<meta name="author" content="Cillian" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This article will explore a variety of methods to identify, chain and exploit POST-Based CSRF to maximize the severity of your findings." />
<meta property="og:description" content="This article will explore a variety of methods to identify, chain and exploit POST-Based CSRF to maximize the severity of your findings." />
<link rel="canonical" href="http://localhost:4000/2019/05/23/Exploiting-Post-Based-CSRF.html" />
<meta property="og:url" content="http://localhost:4000/2019/05/23/Exploiting-Post-Based-CSRF.html" />
<meta property="og:site_name" content="/home/Gal1leo" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-23T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Exploiting POST-Based CSRF" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Cillian"},"dateModified":"2019-05-23T00:00:00+01:00","datePublished":"2019-05-23T00:00:00+01:00","description":"This article will explore a variety of methods to identify, chain and exploit POST-Based CSRF to maximize the severity of your findings.","headline":"Exploiting POST-Based CSRF","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/05/23/Exploiting-Post-Based-CSRF.html"},"url":"http://localhost:4000/2019/05/23/Exploiting-Post-Based-CSRF.html"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <header>
      <div class="container">
        <a id="a-title" href="/">
          <h1>/home/Gal1leo</h1>
        </a>
        <h2>Computer Science student. Interested in web exploitation, programming and cyber security. Occasionally partake in CTFs and bug bounties.</h2>

        <section id="downloads">
          
          <a href="" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <small>23 May 2019</small>
<h1>Exploiting POST-Based CSRF</h1>

<p class="view">by Cillian</p>

<p>This article will explore a variety of methods to identify, chain and exploit POST-Based CSRF to maximize the severity of your findings.</p>

<!-- read more -->

<h2 id="what-is-post-based-csrf">What Is POST-Based CSRF?</h2>

<p>POST-Based CSRF, as opposed to GET-Based CSRF, is a type of CSRF which affects POST requests. These, unlike GET requests, contain a body which means they cannot be exploited simply using an image. Instead, one must create a specially crafted page in order to execute the CSRF. This is where a lot of newer hackers fail, as they are not aware that this is possible, so it’s something that’s very important to be familiar with!</p>

<h2 id="the-login-csrf-mistake">The Login CSRF Mistake</h2>

<p>Logout CSRF is not accepted as a valid submission in a lot of bounty programs, and for a very good reason. However, a lot of bounty programs mistakingly inlude login CSRF under the same umbrella. While the severity of login CSRF is generally pretty low, it can be easily used in a chain attack to convert self XSS into stored XSS. Imagine a scenario where you identify self XSS on <code class="language-plaintext highlighter-rouge">victim.com</code>, another vulnerability which is usually out of scope due to the unlikely user interaction required to execute a payload (self XSS, generally speaking, will require the user themselves to insert the payload, arguments have been made that users could be convinced into doing so, but naturally users could be convinced to insert payloads into their browser console all the same, which would have the same desired effect). So these are 2 vulnerabilities which are “worthless” according to the majority of vulnerability disclosure programs. You find this self XSS on <code class="language-plaintext highlighter-rouge">somerandompage.php</code> and notice there is no CSRF token, or other anti-CSRF measure, on the login form (<code class="language-plaintext highlighter-rouge">login.php</code>). Firstly, you must register an account on the website (we’ll create an account called <code class="language-plaintext highlighter-rouge">user</code> with the password <code class="language-plaintext highlighter-rouge">pass</code>) and next, you should insert the payload on <code class="language-plaintext highlighter-rouge">somerandompage.php</code>. Now whenever YOU visit that page, the code will execute. In fact, whenever anyone at all who is logged into your account sees that page, they too will execute the payload. Next, we must create a page exploiting the login CSRF in order to automatically log your victim in. You then create your own website <code class="language-plaintext highlighter-rouge">evil.com</code> and include the following PoC source code:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- This is a HTML comment --&gt;</span>

<span class="c">&lt;!-- Create a form pointing to the login page using the POST protocol --&gt;</span>
<span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">"https://victim.com/login.php"</span> <span class="na">method=</span><span class="s">"POST"</span><span class="nt">&gt;</span>
<span class="c">&lt;!-- Automatically fill the username --&gt;</span>
<span class="nt">&lt;input</span> <span class="na">name=</span><span class="s">"username"</span> <span class="na">value=</span><span class="s">"user"</span><span class="nt">&gt;</span>
<span class="c">&lt;!-- Automatially fill the password --&gt;</span>
<span class="nt">&lt;input</span> <span class="na">name=</span><span class="s">"password"</span> <span class="na">value=</span><span class="s">"pass"</span><span class="nt">&gt;</span>
<span class="c">&lt;!-- Create a login button with ID btn --&gt;</span>
<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"submit"</span> <span class="na">id=</span><span class="s">"btn"</span><span class="nt">&gt;</span>
<span class="nt">&lt;</span><span class="err">!</span><span class="na">-</span> <span class="na">Close</span> <span class="na">the</span> <span class="na">form</span> <span class="na">--</span><span class="nt">&gt;</span>
<span class="nt">&lt;/form&gt;</span>

<span class="c">&lt;!-- Now we must automatically execute the form when a user visits our site, using javascript --&gt;</span>
<span class="nt">&lt;script&gt;</span>
<span class="c1">//This is a javascript comment</span>
<span class="c1">//Simply click the button with ID btn</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">btn</span><span class="dl">"</span><span class="p">).</span><span class="nx">click</span><span class="p">();</span>
<span class="c1">//End of script</span>
<span class="nt">&lt;/script&gt;</span>
<span class="c">&lt;!-- Whenever a user visits this page, they will automatically login to your account --&gt;</span>
</code></pre></div></div>

<p>So that’s cool and all, but we still haven’t actually got the user to visit <code class="language-plaintext highlighter-rouge">somerandompage.php</code> to execute the payload. It seems as though they must automatically visit this, or we have to yet again convince them to click another link, which of course would decrease the severity. This is not the case though! I’ve been experimenting with this recently, to improve the impact of some similar vulnerabilities I’ve discovered and have been creating a second page on the website <code class="language-plaintext highlighter-rouge">evil.com</code> and automatically opening it up in a new tab once a user visits the first page, and then waiting some time (using javascript) before redirecting to <code class="language-plaintext highlighter-rouge">somerandompage.php</code> should work. There are multiple solutions for this, but it feels elegant to wait a few seconds (while the POST request executes) before doing a redirect. This should then redirect them to the page (using the cookies they now have) and execute the payload.</p>

<h2 id="the-anonymous-forms-csrf-mistake">The ‘Anonymous Forms’ CSRF Mistake</h2>
<p>You might have figured by now, that when exploiting POST-Based CSRF to get us XSS, we tend to primarily focus on CSRF classes which are out-of-scope. This is because we know that the only reason these are out-of-scope, is because they exist. So, if we find Self XSS, similar to above, in one of these ‘anonymous forms’ (which just means you don’t have to be logged in to use it/it is in no way connected to your account), then we are easily able to exploit this to get XSS using the same method mentioned above.</p>

<h2 id="identifying-post-based-csrf">Identifying POST-Based CSRF</h2>
<p>I think before we move any further into the world of POST-Based CSRF, that’s it’s critical I mention how we actually identify this. A lot of new hackers will make some obvious mistakes here, which will lead them to wasting valuable time on an endpoint which is not vulnerable. There’s a few ways websites protect against POST-Based CSRF.</p>

<h3 id="csrf-tokens">CSRF Tokens</h3>
<p>You will see these tokens in the body of the request. This is where the data is being sent for the POST request. You’ll see it look something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xyz=123&amp;username=you&amp;password=yourpassword&amp;csrf_token=157be8b852cb6dd8536cb4d662718825
</code></pre></div></div>

<p>The first 3 parameters <code class="language-plaintext highlighter-rouge">xyz</code>, <code class="language-plaintext highlighter-rouge">username</code> and <code class="language-plaintext highlighter-rouge">password</code> could literally be anything, but it’s the <code class="language-plaintext highlighter-rouge">csrf_token</code> that we care about. Remember, this could be literally anything. If you see this, it doesn’t mean it’s not vulnerable! Try omitting it, or removing a single character (what I do). Sometimes they will check that the parameter is set, but forget to check the value of it!</p>

<h3 id="csrf-headers">CSRF Headers</h3>
<p>Some websites utilize headers for their CSRF tokens. It’ll look something like: <code class="language-plaintext highlighter-rouge">X-CSRF-Token</code> and will contain another string. I recommend for testing this, to remove all ‘non predictable’ parameters from both the body &amp; headers of the request. Cookies are an exception, as the browser automatically accepts this. Every ‘static’ parameter you can add to your exploit script (for the body). The header, you really can’t modify, so you’re going to want to remove everything that the browser doesn’t automatically place there from the intercepted request!</p>

<h3 id="referer-headers">Referer Headers</h3>
<p>The <code class="language-plaintext highlighter-rouge">referer</code> header (which humourously misspells ‘referrer’), is another method I encountered recently which actually prevented CSRF. However, the website in question didn’t validate that the <code class="language-plaintext highlighter-rouge">referer</code> header was coming from the same origin. The browser will automatically add the origin of our exploit script to the <code class="language-plaintext highlighter-rouge">referer</code> header when we actually use the exploit script I posted above! So that actually bypassed the protection for me.</p>

<h2 id="the-end">The End</h2>
<p>Now that you know what POST-Based CSRF is, how to exploit it, why we care about it &amp; how to get those valuable bounties from it, I think it’s time to end this post. If you have any questions, feel free to message me on twitter <a href="https://twitter.com/loosesecurity">@LooseSecurity</a>. I’m always happy to help! Thanks for reading &amp; I hope you learned something new from this article.</p>



  <small>tags: <em>csrf</em> - <em>bug bounty</em></small>


      </section>
    </div>
  </body>
</html>
