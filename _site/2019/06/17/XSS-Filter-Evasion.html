<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup theme-color -->
<!-- start theme color meta headers -->
<meta name="theme-color" content="#151515">
<meta name="msapplication-navbutton-color" content="#151515">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- end theme color meta headers -->


<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->


<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>XSS Filter Evasion | /home/Gal1leo</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="XSS Filter Evasion" />
<meta name="author" content="Cillian" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="You’re testing a web application and finally find an endpoint that is reflecting HTML code. You drop your XSS payload and BOOM! All your hopes and dreams vanish before your eyes as that damn WAF appears out of nowhere, only to laugh at you." />
<meta property="og:description" content="You’re testing a web application and finally find an endpoint that is reflecting HTML code. You drop your XSS payload and BOOM! All your hopes and dreams vanish before your eyes as that damn WAF appears out of nowhere, only to laugh at you." />
<link rel="canonical" href="http://localhost:4000/2019/06/17/XSS-Filter-Evasion.html" />
<meta property="og:url" content="http://localhost:4000/2019/06/17/XSS-Filter-Evasion.html" />
<meta property="og:site_name" content="/home/Gal1leo" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-06-17T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="XSS Filter Evasion" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Cillian"},"dateModified":"2019-06-17T00:00:00+01:00","datePublished":"2019-06-17T00:00:00+01:00","description":"You’re testing a web application and finally find an endpoint that is reflecting HTML code. You drop your XSS payload and BOOM! All your hopes and dreams vanish before your eyes as that damn WAF appears out of nowhere, only to laugh at you.","headline":"XSS Filter Evasion","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/06/17/XSS-Filter-Evasion.html"},"url":"http://localhost:4000/2019/06/17/XSS-Filter-Evasion.html"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <header>
      <div class="container">
        <a id="a-title" href="/">
          <h1>/home/Gal1leo</h1>
        </a>
        <h2>Computer Science student. Interested in web exploitation, programming and cyber security. Occasionally partake in CTFs and bug bounties.</h2>

        <section id="downloads">
          
          <a href="" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <small>17 June 2019</small>
<h1>XSS Filter Evasion</h1>

<p class="view">by Cillian</p>

<p>You’re testing a web application and finally find an endpoint that is reflecting HTML code. You drop your XSS payload and BOOM! All your hopes and dreams vanish before your eyes as that damn WAF appears out of nowhere, only to laugh at you.</p>

<!-- read more -->

<p>In this blog post I’m going to be detailing how I successfully bypassed an XSS filter to achieve a very interesting reflected XSS vulnerability in an obvious endpoint which had clearly been tested by hundreds of security researchers before me.
This vulnerability just so happens to be the very same one that my 2nd challenge over on <a href="http://m0z.altervista.org">My Challenge Site</a>.</p>

<h2 id="the-beginning">The Beginning</h2>

<p>Lets take it back to where it all started. I think this vulnerability emphasizes the fact that every little piece of information can be useful at a later date. I noticed that the website I was testing was reflecting the input of a parameter inside of an input tag. This is pretty standard behaviour and it looked something like:</p>

<p><code class="language-plaintext highlighter-rouge">&lt;input name="param1" value=$param1&gt;</code></p>

<p>The idea is that the corresponding value of the GET parameter <code class="language-plaintext highlighter-rouge">param1</code> is reflected into the above input box’s value. The input is escaped correctly, so the tag cannot be closed, and furthermore the characters <code class="language-plaintext highlighter-rouge">&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;</code> are completely blocked by the WAF making it virtually impossible to spawn your own HTML tags.
The one detail you might notice about this scenario is the the value of <code class="language-plaintext highlighter-rouge">$param1</code> is not enclosed within any quotations, meaning that we can spawn a new attribute on that very same input tag by dropping a space.
So now it seems as though we’ve cracked it, we can drop a space and use the <code class="language-plaintext highlighter-rouge">onfocus</code> event handler, along with the <code class="language-plaintext highlighter-rouge">autofocus</code> attribute to instantly execute our javascript the moment a victim visits our link. But of course this is real life, so things are never that simple!</p>

<h2 id="the-waf">The WAF</h2>

<p>Introducing the WAF (edgy music). WAF stands for “Web Application Firewall”, or alternativelty “What the Actual Fuck?!” which tends to be most security researcher’s reaction when they encounter it. WAF is a close relative of the equally annoying “Content Security Policy” but thankfully I didn’t have to deal with that in this case so we’ll leave that for another blog post.
The WAF was doing 2 really distinct actions. Firstly it was completely blocking any requestions which contained HTML, which included all event handlers (<code class="language-plaintext highlighter-rouge">onfocus</code>). Secondly it was stripping key javascript functions such as <code class="language-plaintext highlighter-rouge">alert</code>, <code class="language-plaintext highlighter-rouge">prompt</code>, <code class="language-plaintext highlighter-rouge">console.log</code> and pretty much everything you would ever need for an XSS PoC. It even stripped <code class="language-plaintext highlighter-rouge">document.cookie</code>!
It sounds pretty secure, we’re blocked from adding any event handlers, which means there is literally no way we can obtain XSS, and this is true, I didn’t find some magical way of bypassing that. I tried a lot of different handlers but in the end none of them were allowed.
The actual solution to this lies in their “additional security measures”, which in this case was their stripping of keywords such as <code class="language-plaintext highlighter-rouge">alert</code>, <code class="language-plaintext highlighter-rouge">prompt</code>, etc. I had to think outside the box and realized a realistic attack scenario which would work in the event that the stripping happened after the blocks, which it usually would!
The blocks were being incurred by the WAF, which read the request data before the web application ever got its hands on it. That way it could safely discard it. But then the web application was stripping those javascript keywords, which happened afterwards. The idea was to create a payload that when sent would not be blocked by the WAF, but once the application received it and stripped those keywords, it would now be a working payload.</p>

<h2 id="getting-the-poc">Getting The PoC</h2>
<p>Finally it was time to fire up a payload. We know the <code class="language-plaintext highlighter-rouge">onload</code> event handler is being blocked. We know <code class="language-plaintext highlighter-rouge">alert</code> and <code class="language-plaintext highlighter-rouge">document.cookie</code> are also both being stripped.
So I decided that <code class="language-plaintext highlighter-rouge">alert</code> would be my ‘packaging’ which would allow me to package up the payload so that it safely evaded the WAF, but was then discarded by the web application.
The final payload:</p>

<p>` oalertnfocus=alalertert(documealertnt.cookie) autofocus`</p>

<p>Which combined to spawn the full input element on the page after the <code class="language-plaintext highlighter-rouge">alert</code> keyword was stripped:</p>

<p><code class="language-plaintext highlighter-rouge">&lt;input name="param1" value= onfocus=alert(document.cookie) autofocus&gt;</code></p>

<h2 id="the-end">The End</h2>
<p>I know this post was short, but I’m hoping it provided you with some thought-provoking material with regards to WAF bypassing techniques, as well as web application created filter evasion. If you have any questions, feel free to message me on twitter <a href="https://twitter.com/loosesecurity">@LooseSecurity</a> or join my <a href="https://discord.gg/qStuRZS">Discord</a>. I’m always happy to help! Thanks for reading &amp; I hope you learned something new from this article.</p>



  <small>tags: <em>xss</em> - <em>filter evasion</em></small>


      </section>
    </div>
  </body>
</html>
