I"ƒ<p>You‚Äôre testing a web application and finally find an endpoint that is reflecting HTML code. You drop your XSS payload and BOOM! All your hopes and dreams vanish before your eyes as that damn WAF appears out of nowhere, only to laugh at you.</p>

<!-- read more -->

<p>In this blog post I‚Äôm going to be detailing how I successfully bypassed an XSS filter to achieve a very interesting reflected XSS vulnerability in an obvious endpoint which had clearly been tested by hundreds of security researchers before me.
This vulnerability just so happens to be the very same one that my 2nd challenge over on <a href="http://m0z.altervista.org">My Challenge Site</a>.</p>

<h2 id="the-beginning">The Beginning</h2>

<p>Lets take it back to where it all started. I think this vulnerability emphasizes the fact that every little piece of information can be useful at a later date. I noticed that the website I was testing was reflecting the input of a parameter inside of an input tag. This is pretty standard behaviour and it looked something like:</p>

<p><code class="language-plaintext highlighter-rouge">&lt;input name="param1" value=$param1&gt;</code></p>

<p>The idea is that the corresponding value of the GET parameter <code class="language-plaintext highlighter-rouge">param1</code> is reflected into the above input box‚Äôs value. The input is escaped correctly, so the tag cannot be closed, and furthermore the characters <code class="language-plaintext highlighter-rouge">&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;</code> are completely blocked by the WAF making it virtually impossible to spawn your own HTML tags.
The one detail you might notice about this scenario is the the value of <code class="language-plaintext highlighter-rouge">$param1</code> is not enclosed within any quotations, meaning that we can spawn a new attribute on that very same input tag by dropping a space.
So now it seems as though we‚Äôve cracked it, we can drop a space and use the <code class="language-plaintext highlighter-rouge">onfocus</code> event handler, along with the <code class="language-plaintext highlighter-rouge">autofocus</code> attribute to instantly execute our javascript the moment a victim visits our link. But of course this is real life, so things are never that simple!</p>

<h2 id="the-waf">The WAF</h2>

<p>Introducing the WAF (edgy music). WAF stands for ‚ÄúWeb Application Firewall‚Äù, or alternativelty ‚ÄúWhat the Actual Fuck?!‚Äù which tends to be most security researcher‚Äôs reaction when they encounter it. WAF is a close relative of the equally annoying ‚ÄúContent Security Policy‚Äù but thankfully I didn‚Äôt have to deal with that in this case so we‚Äôll leave that for another blog post.
The WAF was doing 2 really distinct actions. Firstly it was completely blocking any requestions which contained HTML, which included all event handlers (<code class="language-plaintext highlighter-rouge">onfocus</code>). Secondly it was stripping key javascript functions such as <code class="language-plaintext highlighter-rouge">alert</code>, <code class="language-plaintext highlighter-rouge">prompt</code>, <code class="language-plaintext highlighter-rouge">console.log</code> and pretty much everything you would ever need for an XSS PoC. It even stripped <code class="language-plaintext highlighter-rouge">document.cookie</code>!
It sounds pretty secure, we‚Äôre blocked from adding any event handlers, which means there is literally no way we can obtain XSS, and this is true, I didn‚Äôt find some magical way of bypassing that. I tried a lot of different handlers but in the end none of them were allowed.
The actual solution to this lies in their ‚Äúadditional security measures‚Äù, which in this case was their stripping of keywords such as <code class="language-plaintext highlighter-rouge">alert</code>, <code class="language-plaintext highlighter-rouge">prompt</code>, etc. I had to think outside the box and realized a realistic attack scenario which would work in the event that the stripping happened after the blocks, which it usually would!
The blocks were being incurred by the WAF, which read the request data before the web application ever got its hands on it. That way it could safely discard it. But then the web application was stripping those javascript keywords, which happened afterwards. The idea was to create a payload that when sent would not be blocked by the WAF, but once the application received it and stripped those keywords, it would now be a working payload.</p>

<h2 id="getting-the-poc">Getting The PoC</h2>
<p>Finally it was time to fire up a payload. We know the <code class="language-plaintext highlighter-rouge">onload</code> event handler is being blocked. We know <code class="language-plaintext highlighter-rouge">alert</code> and <code class="language-plaintext highlighter-rouge">document.cookie</code> are also both being stripped.
So I decided that <code class="language-plaintext highlighter-rouge">alert</code> would be my ‚Äòpackaging‚Äô which would allow me to package up the payload so that it safely evaded the WAF, but was then discarded by the web application.
The final payload:</p>

<p>` oalertnfocus=alalertert(documealertnt.cookie) autofocus`</p>

<p>Which combined to spawn the full input element on the page after the <code class="language-plaintext highlighter-rouge">alert</code> keyword was stripped:</p>

<p><code class="language-plaintext highlighter-rouge">&lt;input name="param1" value= onfocus=alert(document.cookie) autofocus&gt;</code></p>

<h2 id="the-end">The End</h2>
<p>I know this post was short, but I‚Äôm hoping it provided you with some thought-provoking material with regards to WAF bypassing techniques, as well as web application created filter evasion. If you have any questions, feel free to message me on twitter <a href="https://twitter.com/loosesecurity">@LooseSecurity</a> or join my <a href="https://discord.gg/qStuRZS">Discord</a>. I‚Äôm always happy to help! Thanks for reading &amp; I hope you learned something new from this article.</p>
:ET